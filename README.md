# Ясная Архитектура

На данном курсе мы рассмотрим на практике все ныне существующие и более-менее активно применяющиеся стили и архитектуры программирования. Под стилями будем понимать подход, в мировой практике известный как programming in small -- собственно программирование как оно есть (императивное, функциональное, декларативное, метапрограммирование и т. д., а так же такие концепции, как ООП, акторы, аспекты иже с ними).

Однако для построения реальных масштабных и сверхсложных систем на миллиарды пользователей знания стилей программирования оказывается совершенно недостаточно. Тут на первый план выходят совсем иные концепции, связанные прежде всего с проектированием структуры огромного количества кода таким образом, чтобы максимально снизить его сложность, уменьшить внутренние связи и в идеале избавиться от явного хранения любых промежуточных состояний. Сюда же отнесём оптимальное распределение нагрузки (на процессоры, оперативную память, диски, сеть...) между клиентами и серверами, которые могут взаимодействовать самым причудливым образом. Этот подход известен как programming in large. В сумме же всех известных и реально применяемых технологических паттернов programming in small и programming in large насчитывается не так и много -- два-три десятка.

Данный курс позволяет быстро изучить на практических примерах все эти подходы -- так, чтобы сразу начать применять их в своей работе. При этом на изучение каждой технологии потребуется символическое время, 15-30 минут. Главный упор в курсе делается на постепенную сравнительность подходов, когда ключевые различия, плюсы и минусы становятся особо наглядными.

Все примеры приводятся на языке Python; синтаксис этого языка настолько прозрачен, что наверняка будет понятен всем.


## 1. Постановка задачи:
В качестве примера возьмем достаточно простую задачу дистанционного управления роботом-дворником, который скоро придёт на смену очень многим, не желающим совершенствоваться в программировании :)

Робот понимает команды Move (двигаться вперед на заданное число метров), Turn (поворот на месте на заданный угол в градусах), Set (выбрать одно из трёх устройств очистки: полив водой, полив мыльной пеной, чистка метлой), Start (включить устройство очистки) и Stop (выключить устройство очистки).

Условно говоря, мы управляем роботом с помощью некоторого простейшего языка предметной области, domain-specific language (DSL), это тоже один из стилей программирования, который очень любит великий Алан Кей со своей вычисляемой математикой (тысячекратная компактность кода). Это будет некоторый условный язык программирования.

Набор управляющих команд роботу -- это и есть своеобразная программа на нашем DSL, которую мы будем интерпретировать.

Входная программа управления роботом представляет собой список команд (строки), которые выполняются последовательно одна за одной. Например:

    'move 100',
    'turn -90',
    'set soap',
    'start',
    'move 50',
    'stop'

Команда set может принимать один из трёх параметров water (полив водой; исходное по умолчанию), soap (мыльная пена), brush (метла).

Программа, получая такую последовательность команд, после выполнения каждой из них выводит в консоль:
-- либо текущую позицию: POS x,y (команда move),
-- либо текущий угол поворота в градусах: ANGLE a (команда turn),
-- либо текущее состояние устройства очистки (одно из трёх): STATE water/soap/brush (команда set),
-- либо начало работы с текущим состоянием устройства очистки: START WITH water/soap/brush (команда start),
-- либо прекращение работы: STOP (команда stop).

Реализуйте такую программу любым удобным вам способом.

---

## 2. Процедурный стиль

 Процедура -- это такое понятие из computer science, которое сегодня больше известно как функция. В декларативной модели программирования процедура -- это "функция", которая не возвращает значение, однако результат её может возвращаться через параметры (которые передаются по ссылке). По сути, процедура -- это функция, у которой может быть много (или ноль) входов и много (или ноль) выходов. Ещё корректнее сказать, что первична именно процедура, а функция -- это процедура с единственным выходом.

Отличие от спагетти прежде всего в том, что код, выполненный в процедурном стиле, становится модульным -- во-первых, многократно повторяемые части кода выносятся в автономные процедуры (функции) и гибко параметризуются.
Во-вторых, разрабатывать программу можно (рекомендуется) сверху вниз: сперва пишется основной алгоритм, в котором более мелкие или плохо понятные вещи выделяются в процедуры, реализуемые позже. Таким образом, можно создавать очень и очень объёмные системы. По сути, если выполнять такие шаги аккуратно и продуманно, названия процедур сложатся в своеобразный язык предметной области (DSL), максимально заточенный под конкретную задачу. Это так называемое структурное программирование Дейкстры.

Такой вроде бы не слишком сложный подход однако предоставляет качественно новые возможности. На его основе в 20-м веке десятки лет реализовались сложнейшие проекты в самых разных областях, от проектирования подводных лодок и разработки ядерного оружия до прорывных математических исследований в computer science.

1) Реализуйте управление роботом теперь с помощью функций, так, как вы это поняли.


---

## 3. Теперь рассмотрим код управления роботом-дворником, выполненный в объектно-ориентированном стиле.

1) Реализуйте управление роботом с помощью ООП, так, как вы это понимаете.


---

## 4. Модульный стильё

1) Реализуйте управление роботом в модульном стиле, так, как вы это понимаете.

---

## 5. Типовая хипстерская архитектура

1) Реализуйте API к данному модулю так, как вы это понимаете. Каким конкретно техническим способом клиентам представляется доступ к этому API, мы не рассматриваем.

## 6. Stateless-архитектура

1) Казалось бы, невозможно сделать систему, где по смыслу наш робот может находиться в промежуточных состояниях, но никаких внутренних переменных или объектов мы не создаём. Конечно, эти состояния в системе в виде некоторой абстракции так или иначе будут присутствовать. Наша задача в другом -- избавиться от любых явных мутабельных элементов в системе. Здесь существует несколько интересных подходов, один из которых мы рассмотрим далее.

Предварительно попробуйте самостоятельно придумать и реализовать stateless-архитектуру так, как вы это понимаете.